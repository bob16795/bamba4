def Types: import "types.bam";
def TopExpression: import "expressions.bam".TopExpression;
def TopStatement: import "statements.bam".TopStatement;
def Statements: import "statements.bam";
def Functions: import "functions.bam";
def Error: import "error.bam".Error;
def LLVM: import "lib/llvm.bam";

def Value: class {
    def Builtins: class {
        def SizeOf: 0;
        def HasDef: 1;
        def TypeOf: 2;
        def Name: 3;
        def EnumRepr: 4;
    };

    def Kind: class {
        def Unvisited: 0;
        def Link: 1;

        def KClass: 2;
        def Function: 3;
        def ConstInt: 4;
        def IntType: 5;
        def PtrType: 6;
        def ArrayType: 7;
        def VoidType: 8;
        def RtValue: 9;
        def TypeType: 10;
        def ConstBool: 11;
        def ConstString: 12;
        def ConstEnum: 13;
        def EnumType: 14;
        def NullValue: 15;
        
        def BuiltinFunc: 16;
        
        def Prop: 17;
        def Method: 18;
    };

    def Compare: class {
        def Lt: u8(0);
        def Eql: u8(1);
        def NotEql: u8(2);
        def Gt: u8(3);
    };
    
    def Operation: class {
        def Add: u8(0);
        def Sub: u8(1);
        def Mul: u8(2);
        def Div: u8(3);
        def Mod: u8(4);
    };

    def MethodData: class {
        def parent: prop Value;
        def function: prop Value;

        def `drop`: fn[Self: *Self] -> Void {
            return;
        };
    };

    def PropData: class {
        def id: prop u8;
        def kind: prop Value;

        def `drop`: fn[Self: *Self] -> Void {
            Self.`drop`(self.kind);

            return;
        };
    };

    def UnvisitedData: class {
        def top: prop TopExpression;
        def name: prop std.Types.Slice(u8);
        def ctx: prop *Context;

        def `drop`: fn[Self: *Self] -> Void {
            TopExpression.`drop`(self.top);

            return;
        };
    };

    def IntTypeData: class {
        def size: prop u32;
        def signed: prop Bool;

        def `drop`: fn[Self: *Self] -> Void {
            return;
        };
    };

    def FunctionData: class {
        def Param: class {
            def name: prop std.Types.Slice(u8);
            def value: prop Value;
        };
    
        def OutputType: std.Types.Option(Value);
        def InputType: std.Types.ArrayList(Param);

        def ImplType: std.Types.HashMap(std.Types.String, LLVM.lValue);
        def KindType: std.Types.HashMap(std.Types.String, Value);
       
        def isExtern: prop Bool;
        def output: prop OutputType;
        def input: prop InputType;
        def impls: prop ImplType;
        def kinds: prop KindType;
        def kind: prop LLVM.lType;
    
        def body: prop TopStatement;
        def name: prop std.Types.Slice(u8);
        def ctx: prop Context;

        def `drop`: fn[Self: *Self] -> Void {
            OutputType.`drop`(self.output);
            InputType.`drop`(self.input);
            ImplType.`drop`(self.impls);

            if (!*self.isExtern) {
                TopExpression.`drop`(self.body);
            }

            return;
        };
    };
    
    def RtData: class {
        def value: prop LLVM.lValue;
        def kind: prop Value;
    };

    def ClassData: class {
        def ValuesT: std.Types.HashMap(std.Types.Slice(u8), Value);
        def NameT: std.Types.Slice(u8);

        def values: prop ValuesT;
        def name: prop NameT;
        def kind: prop LLVM.lType;
        def len: prop u8;
    };

    def kind: prop u8;
    def data: prop *Void;

    def print: fn[self: *Self] -> Void {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        std.Types.printf("value of %d", *self.kind);

        return;
    };

    def isPointerTo: fn[self: *Self, to: *Self] -> Bool {
        return Bool(false);
    };
    
    def newProp: fn[kind: Value] -> Self {
        def data: (*PropData)(std.Types.malloc(PropData.SIZE));
        data.id = u8(0);
        data.kind = kind;

        return Self($[u8(Kind.Prop), (*Void)(data)]);
    };
    
    def newBuiltin: fn[kind: usize] -> Self {
        def data: (*usize)(std.Types.malloc(usize.SIZE));
        data = kind;

        return Self($[u8(Kind.BuiltinFunc), (*Void)(data)]);
    };

    def newMethod: fn[parent: *Value, function: *Value] -> Self {
        def data: (*MethodData)(std.Types.malloc(MethodData.SIZE));
        data.parent = *parent;
        data.function = *function;

        return Self($[u8(Kind.Method), (*Void)(data)]);
    };


    def newRtValue: fn[value: LLVM.lValue, kind: Value] -> Self {
        def data: (*RtData)(std.Types.malloc(RtData.SIZE));
        data.value = value;
        data.kind = kind;

        return Self($[u8(Kind.RtValue), (*Void)(data)]);
    };

    def newPtrType: fn[child: Value] -> Self {
        def data: (*Value)(std.Types.malloc(Value.SIZE));
        data = child;

        return Self($[u8(Kind.PtrType), (*Void)(data)]);
    };

    def newArrayType: fn[child: Value] -> Self {
        def data: (*Value)(std.Types.malloc(Value.SIZE));
        data = child;

        return Self($[u8(Kind.ArrayType), (*Void)(data)]);
    };

    def newClass: fn[] -> Self {
        def data: (*ClassData)(std.Types.malloc(ClassData.SIZE));
        data.name = ClassData.NameT.initFrom("Anon", usize(4));
        data.values = ClassData.ValuesT.init();
        data.kind = null;
        data.len = u8(0);

        return Self($[u8(Kind.KClass), (*Void)(data)]);
    };

    def newFunction: fn[
        output: std.Types.Option(Value),
        input: std.Types.ArrayList(FunctionData.Param),
        body: TopStatement,
        ctx: *Context,
        isExtern: Bool
    ] -> Self {
        def data: (*FunctionData)(std.Types.malloc(FunctionData.SIZE));
        data.isExtern = isExtern;
        data.body = body;
        data.name = ClassData.NameT.initFrom("Anon", usize(4));
        data.output = output;
        data.input = input;
        data.impls = (*data.impls).TYPE.init();
        data.kinds = (*data.kinds).TYPE.init();
        data.ctx = ctx.clone();

        return Self($[u8(Kind.Function), (*Void)(data)]);
    };
    
    def newConstBool: fn[b: Bool] -> Self {
        def data: (*Bool)(std.Types.malloc(Bool.SIZE));
        data = b;

        return Self($[u8(Kind.ConstBool), (*Void)(data)]);
    };

    def newConstInt: fn[data: usize] -> Self {
        return Self($[u8(Kind.ConstInt), (*Void)(data)]);
    };
    
    def newConstString: fn[slice: std.Types.Slice(u8)] -> Self {
        def SliceT: comptime {
            return std.Types.Slice(u8);
        };

        def data: (*SliceT)(std.Types.malloc(SliceT.SIZE));
        data = slice;

        return Self($[u8(Kind.ConstString), (*Void)(data)]);
    };

    def newIntType: fn[size: u32, signed: Bool] -> Self {
        def data: (*IntTypeData)(std.Types.malloc(IntTypeData.SIZE));
        data.size = size;
        data.signed = signed;

        return Self($[u8(Kind.IntType), (*Void)(data)]);
    };

    def newVoidType: fn[] -> Self {
        return Self($[u8(Kind.VoidType), (*Void)(null)]);
    };
    
    def newNullValue: fn[] -> Self {
        return Self($[u8(Kind.NullValue), (*Void)(null)]);
    };
    
    def newTypeType: fn[] -> Self {
        return Self($[u8(Kind.TypeType), (*Void)(null)]);
    };
    
    def unvisited: fn[
        top: *TopExpression,
        name: std.Types.Slice(u8),
        ctx: *Context,
    ] -> Self {
        def data: (*UnvisitedData)(std.Types.malloc(UnvisitedData.SIZE));
        data.top = *top;
        data.name = name;
        data.ctx = ctx;

        return Self($[u8(Kind.Unvisited), (*Void)(data)]);
    };
    
    def link: fn[data: *Self] -> Self {
        return Self($[u8(Kind.Link), (*Void)(data)]);
    };
    
    def hasDef: fn[self: *Self, ctx: *Values.Context, name: *std.Types.Slice(u8)] -> Bool {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.KClass)) {
            def data: (*ClassData)(*self.data);
            def result: data.values.get(*name);

            if (result != (*Self)(null)) {
                return Bool(true);
            }
        }

        return Bool(false);
    };
    
    def getChild: fn[self: *Self, ctx: *Values.Context, name: *std.Types.Slice(u8)] -> *Self {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.KClass)) {
            def data: (*ClassData)(*self.data);
            def result: data.values.get(*name);

            if (result != (*Self)(null)) {
                return result;
            }
        }

        if (*self.kind == u8(Kind.RtValue)) {
            def data: (*RtData)(*self.data);
            def baseKind: &Self.ref(data.kind, ctx);

            def kindChild: Self.getChild(baseKind, ctx, name);

            if (kindChild == (*Self)(null)) {
                std.Types.printf("bad parent kind %d ", *self.kind);
                name.print();
                std.Types.printf("\n");

                return (*Self)(null);
            }
        
            def data: new *Self = kindChild;
            while (*(*data).kind == u8(Kind.Link))
                data = *(*data).data;
            def kindSelf: *data;

            Self.visit(kindSelf, ctx);

            if (*kindSelf.kind == u8(Kind.Prop)) {
                def data: (*PropData)(*kindSelf.data);
                def value: (*ctx.builder).buildStructGEP(
                    baseKind.getType(ctx),
                    self.getValue(ctx),
                    *data.id,
                    "Anon",
                );

                def result: (*Self)(std.Types.malloc(Self.SIZE));
                result = newRtValue(value, newPtrType(*data.kind));

                return result;
            }

            if (*kindSelf.kind == u8(Kind.Function)) {
                def result: (*Self)(std.Types.malloc(Self.SIZE));
                result = newMethod(self, kindSelf);

                return result;
            }
        
            std.Types.printf("bad value kind %d ", *kindSelf.kind);
        }

        std.Types.printf("bad parent %d ", *self.kind);
        name.print();
        std.Types.printf("\n");

        return (*Self)(null);
    };
    
    def getValue: fn[self: *Self, ctx: *Values.Context] -> LLVM.lValue {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.RtValue)) {
            def data: (*RtData)(*self.data);

            return *data.value;
        }

        if (*self.kind == u8(Kind.ConstString)) {
            def aadds: new std.Types.String = std.Types.String.fromSlice(*self.data);
            def badds: new std.Types.String = aadds.replace("\\n", "\n");
            drop aadds;
            def aadds: new std.Types.String = badds.replace("\\r", "\r");
            drop badds;

            def string_val: (*ctx.context).constString(aadds.base.items);
            def string: (*ctx.module).addGlobal(string_val.getType(), "Anon");

            string.setInit(string_val);

            return string;
        }

        std.Types.printf("bad value %d\n", *self.kind);

        return (LLVM.lValue)(null);
    };
    
    def tryCast: fn[self: *Self, ctx: *Values.Context, type: *Self] -> Self {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.RtValue)) {
            def data: (*RtData)(*self.data);
            
            return newRtValue(
                *data.value,
                *type,
            );
        } if (*self.kind == u8(Kind.NullValue)) {
            def data: (usize)(*self.data);

            return newRtValue(
                type.getType(ctx).constZero(),
                *type,
            ); 
        } if (*self.kind == u8(Kind.ConstInt)) {
            def data: (usize)(*self.data);

            return newRtValue(
                type.getType(ctx).constInt(data, Bool(false)),
                *type,
            ); 
        } if (*self.kind == u8(Kind.ConstString)) {
            def val: self.getValue(ctx);

            return Self.tryCast(&newRtValue(
                val,
                newPtrType(newArrayType(newIntType(u32(8), Bool(false)))),
            ), ctx, type); 
        } if (*self.kind == u8(Kind.ConstBool)) {
            def data: (Bool)(*self.data);

            return newRtValue(
                (*ctx.context).intType(u32(1)).constInt(usize(data), Bool(false)),
                *type,
            ); 
        }


        std.Types.printf("bad cast %d\n", *self.kind);

        def tmp: new Self;
        tmp = null;

        return *tmp;
    };
    
    def getTypeValue: fn[self: *Self, ctx: *Values.Context] -> Self {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.RtValue)) {
            def data: (*RtData)(*self.data);

            return *data.kind;
        }

        std.Types.printf("bad type value %d\n", *self.kind);

        return (LLVM.lValue)(null);
    };
    
    def exportDrop: fn[self: *Self, ctx: *Values.Context] -> Self {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.PtrType)) {
            def data: (*Self)(*self.data);

            return *data;
        }

        std.Types.printf("cant drop %d\n", *self.kind);

        return (LLVM.lValue)(null);
    };
    
    def ref: fn[self: *Self, ctx: *Values.Context] -> Self {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.PtrType)) {
            def data: (*Self)(*self.data);

            return *data;
        }

        std.Types.printf("bad pointer %d\n", *self.kind);

        return (LLVM.lValue)(null);
    };

    def isType: fn[self: *Self] -> Bool {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        return
            *self.kind == u8(Kind.IntType) |
            *self.kind == u8(Kind.KClass) |
            *self.kind == u8(Kind.PtrType);
    };

    def getType: fn[self: *Self, ctx: *Values.Context] -> LLVM.lType {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.IntType)) {
            def data: (*IntTypeData)(*self.data);

            return (*ctx.context).intType(*data.size);
        }

        if (*self.kind == u8(Kind.ArrayType)) {
            def data: (*Self)(*self.data);

            return data.getType(ctx).arrayType(u32(0));
        }

        if (*self.kind == u8(Kind.PtrType)) {
            def data: (*IntTypeData)(*self.data);

            return (*ctx.context).pointerType(u32(0));
        }

        if (*self.kind == u8(Kind.KClass)) {
            def data: (*ClassData)(*self.data);

            if (*data.kind != (LLVM.lType)(null)) {
                return *data.kind;
            }

            def str: new std.Types.String;
            str = std.Types.String.fromSlice(data.name);
            str.base.append(u8(0));

            data.kind = (*ctx.context).createNamedStruct(*str.base.items.ptr);

            def i: new usize = usize(0);

            def NodeT: ((*data.values).TYPE).EntryElem.Node;
            def body: new comptime {
                return std.Types.ArrayList(LLVM.lType);
            };
            body.init();
            body.ensureLen(*data.len);

            while (*i < usize(128)) {
                def entry: data.values.entrys[*i];
                def current: new *NodeT = *entry.head;

                while (*current != (*NodeT)(null)) {
                    def tdata: new *Self = (*current).data.value;
                    while (*(*tdata).kind == u8(Kind.Link))
                        tdata = *(*tdata).data;
                    def link: *tdata;

                    if (*link.kind == u8(Kind.Prop)) {
                        def tdata: (*PropData)(*link.data);

                        body[*tdata.id] = tdata.kind.getType(ctx);
                    }

                    current = *(*current).next;
                }
                
                i = *i + usize(1);
            }

            (*data.kind).setBody(body.items);

            return *data.kind;
        }

        return (LLVM.lType)(null);
    };
    
    def getName: fn[self: *Self] -> std.Types.Slice(u8) {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.Function)) {
            def data: (*FunctionData)(*self.data);

            return *data.name;
        } else if (*self.kind == u8(Kind.RtValue)) {
            def word: comptime {
                return std.Types.Slice(u8);
            }($["", usize(0)]);

            return word;
        } else if (*self.kind == u8(Kind.KClass)) {
            def data: (*ClassData)(*self.data);

            return *data.name;
        }

        def word: comptime {
            return std.Types.Slice(u8);
        }($["", usize(0)]);

        return word;
    };

    def setName: fn[self: *Self, name: std.Types.Slice(u8)] -> Void {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.Function)) {
            // TODO: implement
            def word: comptime {
                return std.Types.Slice(u8);
            }($["", usize(0)]);
            def data: (*FunctionData)(*self.data);

            data.name = name;

            def func: data.impls.get(word);

            if (func != (*LLVM.lValue)(null)) {
                (*func).setName(&name);
            }
        } else if (*self.kind == u8(Kind.RtValue)) {
            def data: (*RtData)(*self.data);

            (*data.value).setName(&name);
        } else if (*self.kind == u8(Kind.KClass)) {
            def data: (*ClassData)(*self.data);

            data.name = name;
        }

        return;
    };

    def visit: fn[self: *Self, ctx: *Values.Context] -> *Self {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        def exit: extern fn[] -> Void;

        if (*self.kind == u8(Kind.Unvisited)) {
            def data: (*UnvisitedData)(*self.data);

            def nctx: (*Context)(std.Types.malloc(Context.SIZE));
            nctx = (*data.ctx).clone();

            def res: &TopExpression.visit(data.top, nctx);
            if (*res.isErr) {
                res.errv.print();
                exit(u8(1));
            }
            self = *res.okv;

            self.setName(*data.name);
        }

        return self;
    };

    def export: fn[self: *Self, ctx: *Values.Context] -> *Self {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        def exit: extern fn[] -> Void;

        if (*self.kind == u8(Kind.Unvisited)) {
            def data: (*UnvisitedData)(*self.data);

            def nctx: (*Context)(std.Types.malloc(Context.SIZE));
            nctx = (*data.ctx).clone();

            def res: &TopExpression.export(data.top, nctx);
            if (*res.isErr) {
                res.errv.print();
                exit(u8(1));
            }
            self = *res.okv;

            self.setName(*data.name);
        }

        return self;
    };

    def VisitResult: std.Types.Result(Value, Error);
    
    def array: fn[self: *Self, ctx: *Values.Context] -> VisitResult {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.IntType) |
            *self.kind == u8(Kind.VoidType) |
            *self.kind == u8(Kind.ArrayType) |
            *self.kind == u8(Kind.PtrType) |
            *self.kind == u8(Kind.KClass)) {
            return VisitResult.ok(Value.newArrayType(*self));
        }

        std.Types.printf("array %d\n", *self.kind);

        return VisitResult.err(Error.Unreachable("array export"));
    };

    def deref: fn[self: *Self, ctx: *Values.Context] -> VisitResult {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.RtValue)) {
            def data: (*RtData)(*self.data);
            if (*data.kind.kind != u8(Kind.PtrType)) {
                return VisitResult.err(Error.Unreachable("deref error"));
            }
            def kind: (*Value)(*data.kind.data);
            def type: Self.getType(kind, ctx);
            def value: (*ctx.builder).buildLoad(type, *data.value, "Anon");

            return VisitResult.ok(Value.newRtValue(value, *kind));
        }

        if (*self.kind == u8(Kind.IntType) |
            *self.kind == u8(Kind.VoidType) |
            *self.kind == u8(Kind.ArrayType) |
            *self.kind == u8(Kind.PtrType) |
            *self.kind == u8(Kind.KClass)) {
            return VisitResult.ok(Value.newPtrType(*self));
        }

        std.Types.printf("deref %d\n", *self.kind);

        return VisitResult.err(Error.Unreachable("deref export"));
    };
    
    def index: fn[self: *Self, ctx: *Values.Context, other: *Self] -> VisitResult {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;

        if (*self.kind == u8(Kind.RtValue)) {
            def data: (*RtData)(*self.data);
            if (*data.kind.kind != u8(Kind.PtrType)) {
                return VisitResult.err(Error.Unreachable("index error"));
            }
            def kind: (*Value)(*data.kind.data);
            def type: Self.getType(kind, ctx);
            def otherv: &other.getValue(ctx);
            def slice: &comptime {
                return std.Types.Slice(LLVM.lValue);
            }($[otherv, usize(1)]);

            def value: (*ctx.builder).buildInBoundsGEP(type, *data.value, slice, "Anon");

            return VisitResult.ok(Value.newRtValue(value, newPtrType(*(*Self)(*kind.data))));
        }

        std.Types.printf("index %d\n", *self.kind);

        return VisitResult.err(Error.Unreachable("index export"));
    };

    
    def oper: fn[self: *Self, ctx: *Values.Context, other: *Self, opKind: u8] -> VisitResult {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;
        def data: new *Self = other;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def other: *data;

        if (*self.kind == u8(Kind.ConstInt) &
            *other.kind == u8(Kind.ConstInt)) {

            def a: (usize)(*self.data);
            def b: (usize)(*other.data);

            if (opKind == Operation.Add)
                return VisitResult.ok(newConstInt(a + b));
            if (opKind == Operation.Mul)
                return VisitResult.ok(newConstInt(a * b));
        }

        if (*self.kind == u8(Kind.RtValue)) {
            def a: (*RtData)(*self.data);
            def otherv: (&Self.tryCast(other, ctx, a.kind)).getValue(ctx);
            
            def value: new LLVM.lValue;
            if (opKind == Operation.Add)
                value = (*ctx.builder).buildAdd(*a.value, otherv, "Anon");
            else if (opKind == Operation.Mul)
                value = (*ctx.builder).buildMul(*a.value, otherv, "Anon");
            else 
                return VisitResult.err(Error.Unreachable("oper export"));

            return VisitResult.ok(newRtValue(*value, *a.kind));
        }

        std.Types.printf("oper %d\n", *self.kind);

        return VisitResult.err(Error.Unreachable("oper export"));
    };
    
    def compare: fn[self: *Self, ctx: *Values.Context, other: *Self, compKind: u8] -> VisitResult {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: *data;
        def data: new *Self = other;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def other: *data;

        if (*self.kind == u8(Kind.ConstInt) &
            *other.kind == u8(Kind.ConstInt)) {

            def a: (usize)(*self.data);
            def b: (usize)(*other.data);

            if (compKind == Compare.Eql)
                return VisitResult.ok(newConstBool(a == b));
            if (compKind == Compare.NotEql)
                return VisitResult.ok(newConstBool(a != b));
            if (compKind == Compare.Lt)
                return VisitResult.ok(newConstBool(a < b));
        }

        if (*self.kind == u8(Kind.RtValue)) {
            def a: (*RtData)(*self.data);
            def otherv: (&Self.tryCast(other, ctx, a.kind)).getValue(ctx);

            def value: new LLVM.lValue;
            if (compKind == Compare.Eql)    
                value = (*ctx.builder).buildICmp(u32(32), *a.value, otherv, "Anon");
            else if (compKind == Compare.NotEql)    
                value = (*ctx.builder).buildICmp(u32(33), *a.value, otherv, "Anon");
            else if (compKind == Compare.Lt) 
                value = (*ctx.builder).buildICmp(u32(36), *a.value, otherv, "Anon");
            else
                return VisitResult.err(Error.Unreachable("compare export"));

            return VisitResult.ok(newRtValue(
                *value,
                newIntType(u32(1), Bool(false)),
            ));
        }

        std.Types.printf("compare %d\n", *self.kind);

        return VisitResult.err(Error.Unreachable("compare export"));
    };

    def call: fn[self: *Self, ctx: *Values.Context, params: *std.Types.ArrayList(Value)] -> VisitResult {
        def data: new *Self = self;
        while (*(*data).kind == u8(Kind.Link))
            data = *(*data).data;
        def self: (*data);

        if (*self.kind == u8(Kind.Function)) {
            Values.Value.export(self, ctx);

            def data: (*FunctionData)(*self.data);

            if (data.output.is_some() & *data.output.val.kind == u8(Kind.TypeType)) {
                return Functions.visitCall(self, ctx, params);
            }
                
            def name: new std.Types.String;
            name = std.Types.String.from("");

            def args: new comptime {
                return std.Types.ArrayList(LLVM.lValue);
            };
            args.init();

            def i: new usize = usize(0);

            if (!*data.isExtern & params.len() != data.input.len()) {
                return VisitResult.err(Error.CallError(data.input.len(), params.len()));
            }

            while (*i < params.len()) {
                if (params[*i].isType()) {
                    name.appendSlice(Self.getName(params[*i]));
                } else {
                    if (*i < data.input.len()) {
                        def res: Self.getValue(&params[*i].tryCast(
                            ctx, data.input[*i].value
                        ), ctx);
    
                        args.push(res);
                    } else {
                        def res: Self.getValue(params[*i], ctx);
    
                        args.push(res);
                    }
                }

                i = *i + usize(1);
            }

            def func: Functions.getImpl(self, ctx, *name);
            def outkind: Self.getType(data.output.val, ctx);

            def value: (*ctx.builder).buildCall(*data.kind, func, args.items, "Anon");

            return VisitResult.ok(Value.newRtValue(value, outkind));
        } else if (*self.kind == u8(Kind.BuiltinFunc)) {
            def data: (*usize)(*self.data);

            if (*data == usize(Builtins.HasDef)) {
                return VisitResult.ok(newConstBool(
                    params[usize(0)].hasDef(
                        ctx,
                        *params[usize(1)].data,
                    ),
                ));
            }
            
            if (*data == usize(Builtins.EnumRepr)) {
                def data: new *Self = params[usize(0)];
                while (*(*data).kind == u8(Kind.Link))
                    data = *(*data).data;
                def self: *data;

                return VisitResult.ok(newConstInt(usize(*self.kind)));
            }
            
            if (*data == usize(Builtins.TypeOf)) {
                def kind: params[usize(0)].getTypeValue(ctx);

                return VisitResult.ok(kind);
            }
            
            if (*data == usize(Builtins.SizeOf)) {
                def kind: params[usize(0)].getType(ctx);

                return VisitResult.ok(newConstInt(
                    (*ctx.targetData).sizeOf(kind),
                ));
            }

            return VisitResult.err(Error.Unreachable("builtin"));
        } else if (*self.kind == u8(Kind.Method)) {
            def methodData: (*MethodData)(*self.data);
            def data: (methodData.function).export(ctx);
            def funcData: (*FunctionData)(*data.data);

            def args: new comptime {
                return std.Types.ArrayList(LLVM.lValue);
            };
            args.init();

            if (!*funcData.isExtern & (params.len() + usize(1)) != funcData.input.len()) {
                return VisitResult.err(Error.CallError(funcData.input.len(), params.len() + usize(1)));
            }
                
            def name: new std.Types.String;
            name = std.Types.String.from("");

            args.push((methodData.parent).getValue(ctx));

            def i: new usize = usize(0);

            while (*i < params.len()) {
                if (*i < funcData.input.len()) {
                    def res: Self.getValue(&params[*i].tryCast(
                        ctx, funcData.input[*i + usize(1)].value
                    ), ctx);
    
                    args.push(res);
                } else {
                    def res: Self.getValue(params[*i], ctx);
    
                    args.push(res);
                }

                i = *i + usize(1);
            }

            def func: Functions.getImpl(data, ctx, *name);
            def outkind: Self.getType(funcData.output.val, ctx);

            def value: (*ctx.builder).buildCall(*funcData.kind, func, args.items, "Anon");

            return VisitResult.ok(Value.newRtValue(value, outkind));
        } else {
            if (params.len() == usize(1)) {
                def cast: &params[usize(0)].tryCast(ctx, self);

                if (*cast.kind != u8(0)) {
                    return VisitResult.ok(*cast);
                }
            }
        }

        std.Types.printf("call: %d\n", *self.kind);

        return VisitResult.err(Error.Unreachable("call export"));
    };
};

def Context: class {
    def LocalsT: std.Types.HashMap(std.Types.Slice(u8), Value);
    def SliceT: std.Types.Slice(u8);
    def FilesT: std.Types.HashMap(std.Types.Slice(u8), Value);
    def ExternsT: std.Types.HashMap(std.Types.Slice(u8), LLVM.lValue);
    
    def locals: prop LocalsT;
    def context: prop LLVM.lContext;
    def module: prop LLVM.lModule;
    def builder: prop LLVM.lBuilder;
    def target: prop LLVM.lMachine;
    def targetData: prop LLVM.lTargetData;
    def returned: prop Bool;
    def selfValue: prop Value;
    def func: prop LLVM.lValue;
    def files: prop *FilesT;
    def externs: prop *ExternsT;

    def getLocal: fn[self: *Self, name: std.Types.Slice(u8)] -> *Value {
        def namePtr: &name;
       
        def word: SliceT($["u8", usize(2)]);
        if (namePtr == word) {
            self.locals.put(word, Value.newIntType(u32(8), Bool(false)));
        }
       
        def word: SliceT($["i32", usize(3)]);
        if (namePtr == word) {
            self.locals.put(word, Value.newIntType(u32(32), Bool(true)));
        }
        
        def word: SliceT($["Void", usize(4)]);
        if (namePtr == word) {
            self.locals.put(word, Value.newVoidType());
        }
        
        def word: SliceT($["Type", usize(4)]);
        if (namePtr == word) {
            self.locals.put(word, Value.newTypeType());
        }
        
        def word: SliceT($["Self", usize(4)]);
        if (namePtr == word) {
            return self.selfValue;
        }
        
        def word: SliceT($["null", usize(4)]);
        if (namePtr == word) {
            self.locals.put(word, Value.newNullValue());
        }
        
        def word: SliceT($["@hasDef", usize(7)]);
        if (namePtr == word) {
            def result: (*Value)(std.Types.malloc(Value.SIZE));
            result = Value.newBuiltin(usize(Value.Builtins.HasDef));

            return result;
        }
        
        def word: SliceT($["@enumRepr", usize(9)]);
        if (namePtr == word) {
            def result: (*Value)(std.Types.malloc(Value.SIZE));
            result = Value.newBuiltin(usize(Value.Builtins.EnumRepr));

            return result;
        }
        
        def word: SliceT($["@typeOf", usize(7)]);
        if (namePtr == word) {
            def result: (*Value)(std.Types.malloc(Value.SIZE));
            result = Value.newBuiltin(usize(Value.Builtins.TypeOf));

            return result;
        }
        
        def word: SliceT($["@sizeOf", usize(7)]);
        if (namePtr == word) {
            def result: (*Value)(std.Types.malloc(Value.SIZE));
            result = Value.newBuiltin(usize(Value.Builtins.SizeOf));

            return result;
        }
        
        def word: SliceT($["usize", usize(5)]);
        if (namePtr == word) {
            self.locals.put(word, Value.newIntType(u32(64), Bool(false)));
        }

        return self.locals.get(name);
    };

    def init: fn[] -> Self {
        def result: new Self;
        result.locals = LocalsT.init();
        result.context = LLVM.contextCreate();
        result.module = (*result.context).createModuleWithName("lol");
        result.builder = (*result.context).createBuilder();
        result.target = LLVM.createMachine("x86_64-pc-linux-gnu");
        result.targetData = (*result.target).getData();
        result.selfValue = null;

        result.files = std.Types.malloc(FilesT.SIZE);
        *result.files = FilesT.init();

        result.externs = std.Types.malloc(ExternsT.SIZE);
        *result.externs = ExternsT.init();

        return *result;
    };

    def clone: fn[self: *Self] -> Self {
        def result: new Self;
        result = *self;
        result.locals = self.locals.clone();

        return *result;
    };

    def clone_empty: fn[self: *Self] -> Self {
        def result: new Self;
        result = *self;
        result.locals = LocalsT.init();

        return *result;
    };

    def addLocal: fn[self: *Self, name: std.Types.Slice(u8), value: Value] -> Void {
        def got: self.locals.get(name);

        if (got == (*Value)(null)) {
            self.locals.put(name, value);
            
            return;
        } else {
            //TODO: error
            std.Types.printf("local exists: ");
            (&name).print();
            std.Types.printf("\n");
            
            return;
        }
    };

    def export: fn[self: *Self, path: *u8[]] -> Void {
        std.Types.printf("%x\n", *self.module);
        (*self.target).emitToFile(*self.module, path, u32(1));    
    
        return;
    };

    def `drop`: fn[self: *Self] -> Void {
        std.Types.printf("drop Context\n");

        (*self.target).`drop`();
        (*self.builder).`drop`();
        (*self.module).`drop`();
        (*self.context).`drop`();

        return;
    };
};
